#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer ParticleBufferIn {
    vec4 particlesIn[];
};

layout(std430, binding = 1) buffer ParticleBufferOut {
    vec4 particlesOut[];
};

// Input uniforms
uniform vec2 mousePosition;
uniform float deltaTime;
uniform vec2 iResolution;

// Adjustable parameters
uniform float attractionStrength = 0.75;
uniform float maxAcceleration = 8.0;
uniform float velocityDamping = 0.96;
uniform float bounceCoefficient = 0.4;

// Random number generation
uint seed = 0;
uint wang_hash(uint seed) {
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

float randomFloat() {
    seed = wang_hash(seed);
    return float(seed) / 4294967295.0;
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    
    // Early exit if this thread is beyond the number of particles
    if (gid >= particlesIn.length()) return;
    
    seed = gid + uint(deltaTime * 1000000.0);  // Ensure different random sequences for each particle and frame
    
    vec2 position = particlesIn[gid].xy;
    vec2 velocity = particlesIn[gid].zw;
    
    vec2 normalizedMouse = (mousePosition / iResolution) * 2.0 - 1.0;
    
    vec2 direction = normalizedMouse - position;
    float distance = length(direction);
    
    // Add small random movement to prevent sticking
    vec2 randomMovement = vec2(randomFloat() - 0.5, randomFloat() - 0.5) * 0.001;
    
    vec2 acceleration = normalize(direction + randomMovement) * min(attractionStrength / (distance * distance + 0.1), maxAcceleration);
    
    velocity += acceleration * deltaTime;
    velocity *= velocityDamping;
    position += velocity * deltaTime;
    
    // Boundary checks with small random offset
    if (abs(position.x) > 1.0) {
        position.x = sign(position.x) * (1.0 - randomFloat() * 0.01);
        velocity.x *= -bounceCoefficient;
    }
    if (abs(position.y) > 1.0) {
        position.y = sign(position.y) * (1.0 - randomFloat() * 0.01);
        velocity.y *= -bounceCoefficient;
    }
    
    // Ensure velocity is not too small
    if (length(velocity) < 0.001) {
        velocity = vec2(randomFloat() - 0.5, randomFloat() - 0.5) * 0.01;
    }
    
    particlesOut[gid] = vec4(position, velocity);
}